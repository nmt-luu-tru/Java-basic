### **Giới Thiệu Tính Đóng Gói (Encapsulation) trong Java**

Tính đóng gói là một trong những nguyên lý cốt lõi của lập trình hướng đối tượng (OOP), giúp ẩn giấu chi tiết nội bộ và chỉ cung cấp các thông tin cần thiết ra bên ngoài. Qua bài giảng này, người thuyết trình đi sâu vào việc làm thế nào và tại sao cần sử dụng tính đóng gói trong Java để quản lý dữ liệu và tăng cường tính linh hoạt cho chương trình.

#### **Tính Đóng Gói Là Gì?**
Tính đóng gói (Encapsulation) là việc **giấu các thành phần nội bộ** của một lớp (ví dụ các biến và phương thức), khiến chúng không thể truy cập trực tiếp từ bên ngoài mà phải thông qua các phương thức công khai (public). Điều này cho phép nhà phát triển **kiểm soát việc truy cập và thay đổi** dữ liệu bên trong lớp.

#### **Mục Đích Của Tính Đóng Gói**
1. **Bảo vệ dữ liệu**: Tính đóng gói giúp bảo vệ các giá trị và trạng thái của đối tượng bằng cách chỉ cho phép chỉnh sửa thông qua các phương thức kiểm soát (getter/setter), tránh việc **truy cập trực tiếp** từ bên ngoài mà không có kiểm tra.
2. **Giảm thiểu phức tạp**: Đóng gói giúp **ẩn đi các chi tiết thừa**, làm cho giao diện của lớp trở nên đơn giản và dễ hiểu hơn đối với người dùng.
3. **Tăng tính linh hoạt**: Khi các chi tiết nội bộ được ẩn, nhà phát triển có thể **thay đổi cách xử lý nội bộ** của lớp mà không ảnh hưởng đến phần mã bên ngoài. Điều này giúp dễ dàng bảo trì và nâng cấp phần mềm.
4. **Bảo đảm tính toàn vẹn dữ liệu**: Các phương thức nội bộ kiểm soát việc thay đổi dữ liệu, tránh các lỗi phát sinh do thao tác trực tiếp vào biến mà không qua kiểm tra.

#### **Ví Dụ Về Lớp Không Sử Dụng Tính Đóng Gói**
Trong ví dụ về một lớp **Player** trong game, ta có thể tạo lớp mà không sử dụng tính đóng gói. Điều này dẫn đến việc các biến như `name`, `health`, và `weapon` được khai báo **public**, cho phép truy cập trực tiếp từ bên ngoài. Dưới đây là mã nguồn minh họa:

```java
public class Player {
    public String name;
    public int health;
    public String weapon;

    public void loseHealth(int damage) {
        this.health -= damage;
        if (this.health <= 0) {
            System.out.println("Player was knocked out of the game.");
        }
    }

    public int healthRemaining() {
        return this.health;
    }

    public void restoreHealth(int extraHealth) {
        this.health += extraHealth;
        if (this.health > 100) {
            this.health = 100;
            System.out.println("Player's health is fully restored.");
        }
    }
}
```

Để sử dụng lớp này:

```java
public class Main {
    public static void main(String[] args) {
        Player player = new Player();
        player.name = "Tim";
        player.health = 20;
        player.weapon = "Sword";

        int damage = 10;
        player.loseHealth(damage);
        System.out.println("Remaining health: " + player.healthRemaining());

        damage = 11;
        player.loseHealth(damage);
        System.out.println("Remaining health: " + player.healthRemaining());

        // Truy cập trực tiếp vào biến health
        player.health = 200;
        System.out.println("Manually set health: " + player.healthRemaining());
    }
}
```

**Kết quả:**
```
Remaining health: 10
Player was knocked out of the game.
Remaining health: -1
Manually set health: 200
```

Như bạn có thể thấy, việc truy cập trực tiếp biến `health` có thể dẫn đến tình trạng không mong muốn, như việc thiết lập giá trị `health` lớn hơn 100 mà không qua các kiểm tra.

#### **Hạn Chế Của Việc Không Sử Dụng Tính Đóng Gói**
1. **Mất kiểm soát dữ liệu**: Cho phép truy cập trực tiếp các biến khiến chương trình dễ phát sinh lỗi do **thiếu các kiểm tra cần thiết**.
2. **Phụ thuộc vào tên biến**: Khi tên biến thay đổi, các mã gọi trực tiếp đến biến đó sẽ gặp lỗi và cần chỉnh sửa thủ công.
3. **Không bảo đảm dữ liệu hợp lệ**: Do việc khởi tạo và thay đổi dữ liệu không được kiểm soát qua phương thức, đối tượng có thể ở trạng thái không hợp lệ, ví dụ như `health` của người chơi bằng 0 ngay từ đầu.

#### **Cải Thiện Bằng Tính Đóng Gói**

Bây giờ, chúng ta sẽ sử dụng tính đóng gói để giải quyết các vấn đề đã nêu. Bằng cách **đặt các biến là private** và cung cấp phương thức công khai (public) để truy cập và thay đổi chúng, ta có thể kiểm soát chặt chẽ hơn. Dưới đây là ví dụ cải tiến:

```java
public class Player {
    private String name;
    private int health;
    private String weapon;

    public Player(String name, int health, String weapon) {
        this.name = name;
        this.weapon = weapon;
        if (health > 0 && health <= 100) {
            this.health = health;
        } else {
            this.health = 100; // Mặc định nếu không hợp lệ
        }
    }

    public void loseHealth(int damage) {
        this.health -= damage;
        if (this.health <= 0) {
            System.out.println(name + " was knocked out of the game.");
        }
    }

    public int healthRemaining() {
        return this.health;
    }

    public void restoreHealth(int extraHealth) {
        this.health += extraHealth;
        if (this.health > 100) {
            this.health = 100;
            System.out.println(name + "'s health is fully restored.");
        }
    }

    public String getName() {
        return name;
    }

    public String getWeapon() {
        return weapon;
    }
}
```

Trong lớp `Main`:

```java
public class Main {
    public static void main(String[] args) {
        Player player = new Player("Tim", 20, "Sword");

        int damage = 10;
        player.loseHealth(damage);
        System.out.println("Remaining health: " + player.healthRemaining());

        damage = 11;
        player.loseHealth(damage);
        System.out.println("Remaining health: " + player.healthRemaining());

        // Truy cập thông qua phương thức restoreHealth
        player.restoreHealth(50);
        System.out.println("After restore: " + player.healthRemaining());
    }
}
```

**Kết quả:**
```
Remaining health: 10
Tim was knocked out of the game.
Remaining health: -1
Tim's health is fully restored.
After restore: 100
```

#### **Lợi Ích Của Tính Đóng Gói**
- **Kiểm soát quyền truy cập**: Mã bên ngoài không thể thay đổi trực tiếp các biến mà phải thông qua phương thức công khai, giúp bảo đảm **kiểm soát dữ liệu**.
- **Tăng tính bảo mật và toàn vẹn dữ liệu**: Các phương thức kiểm soát sẽ thực hiện các kiểm tra cần thiết, bảo đảm dữ liệu luôn trong trạng thái hợp lệ.
- **Tính linh hoạt và bảo trì dễ dàng**: Ta có thể thay đổi cách triển khai nội bộ mà không ảnh hưởng đến mã ngoài.

#### **Kết Luận**
Tính đóng gói là một nguyên lý quan trọng trong OOP giúp **bảo vệ dữ liệu, giảm độ phức tạp**, và **tăng khả năng bảo trì** của mã nguồn. Việc sử dụng tính đóng gói qua getter và setter giúp lớp quản lý tốt hơn việc truy cập dữ liệu nội bộ, tránh các lỗi và giữ cho mã dễ dàng bảo trì.
