Bây giờ, đã đến lúc khám phá về **kế thừa** trong Java và hiểu tầm quan trọng của nó.

### Kế thừa là gì?
Kế thừa là một tính năng mạnh mẽ trong lập trình hướng đối tượng cho phép **tái sử dụng mã**. Nó cho phép một **lớp con** (child class) kế thừa các thuộc tính và phương thức từ một **lớp cha** (parent class), tạo thành một cấu trúc phân cấp cha-con. Lớp con có thể tái sử dụng mã từ lớp cha, dẫn đến mã nguồn được tổ chức và dễ bảo trì hơn.

Chúng ta có thể hình dung về **vương quốc động vật**, nơi các loài động vật được phân loại theo phân cấp. Ví dụ, một **con chó** là một loại **động vật**, có nghĩa là nó chia sẻ các đặc điểm với các loài động vật khác nhưng cũng có những đặc điểm riêng biệt.

### Thiết lập lớp Animal
Hãy bắt đầu bằng cách tạo một lớp **Animal** (Động vật), chứa các thuộc tính chung cho tất cả các loài động vật, chẳng hạn như **kích thước** và **trọng lượng**, cũng như các hành vi như **di chuyển** và **kêu**. Trong Java, lớp này sẽ trông như sau:

```java
public class Animal {
    private String type;
    private String size;
    private double weight;

    // Constructor
    public Animal(String type, String size, double weight) {
        this.type = type;
        this.size = size;
        this.weight = weight;
    }

    // Phương thức di chuyển động vật
    public void move(String speed) {
        System.out.println(type + " di chuyển " + speed);
    }

    // Phương thức kêu
    public void makeNoise() {
        System.out.println(type + " phát ra âm thanh nào đó");
    }

    @Override
    public String toString() {
        return "Động vật[type=" + type + ", size=" + size + ", weight=" + weight + "]";
    }
}
```

Lớp này có:
- **Thuộc tính**: `type`, `size`, và `weight`, mô tả động vật.
- **Phương thức**: `move()` và `makeNoise()`, đại diện cho các hành động chung của tất cả động vật.

### Tạo lớp Dog sử dụng Kế thừa
Tiếp theo, chúng ta sẽ tạo một lớp **Dog** (Chó) kế thừa từ **Animal**. Lớp **Dog** sẽ tái sử dụng các thuộc tính và hành vi của **Animal**, nhưng chúng ta cũng có thể thêm các trường và phương thức riêng biệt cho chó, như **hình dạng tai**, **hình dạng đuôi**, và các hành vi như **sủa** và **vẫy đuôi**.

Để làm cho **Dog** kế thừa từ **Animal**, chúng ta sử dụng từ khóa `extends`:

```java
public class Dog extends Animal {
    private String earShape;
    private String tailShape;

    // Constructor cho Dog, gọi constructor của Animal bằng super()
    public Dog(String type, String size, double weight, String earShape, String tailShape) {
        super(type, size, weight);
        this.earShape = earShape;
        this.tailShape = tailShape;
    }

    // Phương thức riêng cho chó
    public void bark() {
        System.out.println("Chó đang sủa");
    }
}
```

Ở đây, chúng ta:
- Kế thừa các thuộc tính và phương thức từ **Animal** bằng cách sử dụng constructor `super()`.
- Thêm các thuộc tính riêng cho **Dog** (`earShape`, `tailShape`) và phương thức **bark**.

### Sử dụng các lớp
Hãy xem cách kế thừa hoạt động trong thực tế. Trong phương thức `main()`, chúng ta có thể tạo một instance của **Animal** và **Dog**:

```java
public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal("Động vật chung", "Khổng lồ", 400);
        doAnimalStuff(animal, "chậm");

        Dog dog = new Dog("Mutt", "Lớn", 50, "Tai rũ", "Đuôi cong");
        doAnimalStuff(dog, "nhanh");
    }

    public static void doAnimalStuff(Animal animal, String speed) {
        animal.makeNoise();
        animal.move(speed);
        System.out.println(animal);
    }
}
```

Trong phương thức `doAnimalStuff()`, chúng ta xử lý cả đối tượng **Animal** và **Dog** theo cùng một cách. Khi chúng ta truyền một đối tượng **Dog**, nó hoạt động vì **Dog** là một lớp con của **Animal**, cho thấy tính linh hoạt mà kế thừa mang lại.

### Tóm tắt
- **Kế thừa** cho phép lớp con (ví dụ: **Dog**) tái sử dụng các thuộc tính và phương thức từ lớp cha (ví dụ: **Animal**).
- Bạn có thể thêm các tính năng riêng cho lớp con mà không làm ảnh hưởng đến lớp cha.
- Kế thừa giúp đơn giản hóa mã và khuyến khích tính tái sử dụng bằng cách cho phép các lớp con được xử lý như các thể hiện của lớp cha.

--- 

### Thêm thuộc tính và phương thức cho lớp Dog

Để làm cho lớp **Dog** độc đáo hơn, ta có thể thêm các thuộc tính và phương thức riêng. Ví dụ, ta có thể thêm thuộc tính **ear shape** và **tail shape**, và các phương thức như **bark**, **run**, **walk**, và **wagTail**:

```java
class Dog extends Animal {
    String earShape;
    String tailShape;
    
    Dog(String type, String earShape, String tailShape) {
        super(type);
        this.earShape = earShape;
        this.tailShape = tailShape;
    }
    
    void bark() {
        System.out.println(type + " barks.");
    }
    
    void wagTail() {
        System.out.println(type + " wags its " + tailShape + " tail.");
    }
}
```

**Kết quả:**

```java
Dog dog = new Dog("Dog", "Perky", "Curled");
dog.bark(); // In ra: Dog barks.
dog.wagTail(); // In ra: Dog wags its Curled tail.
```

### Tạo phương thức toString

Để dễ dàng hiển thị thông tin về đối tượng, ta có thể ghi đè phương thức **toString**:

```java
@Override
public String toString() {
    return "Type: " + type + ", Ear Shape: " + earShape + ", Tail Shape: " + tailShape;
}
```

**Kết quả:**

```java
Dog dog = new Dog("Dog", "Perky", "Curled");
System.out.println(dog.toString()); // In ra: Type: Dog, Ear Shape: Perky, Tail Shape: Curled
```

### Ghi đè phương thức

Khi một lớp con định nghĩa lại một phương thức từ lớp cha, đó được gọi là ghi đè. Ví dụ, ta có thể ghi đè phương thức **makeNoise** của lớp **Animal**:

```java
@Override
void makeNoise() {
    System.out.println(type + " barks loudly!");
}
```

**Kết quả:**

```java
Dog dog = new Dog("Dog", "Perky", "Curled");
dog.makeNoise(); // In ra: Dog barks loudly!
```

### Kết luận

1. **Kế thừa** cho phép lớp con sử dụng các thuộc tính và phương thức của lớp cha.
2. Lớp con có thể **ghi đè** các phương thức của lớp cha để thay đổi hành vi.
3. Có thể **mở rộng** hành vi của lớp cha bằng cách gọi phương thức của nó trong phương thức của lớp con.

### Ví dụ đầy đủ

Dưới đây là mã hoàn chỉnh cho lớp **Animal** và lớp **Dog**:

```java
class Animal {
    String type;

    Animal(String type) {
        this.type = type;
    }

    void makeNoise() {
        System.out.println(type + " makes a noise.");
    }
}

class Dog extends Animal {
    String earShape;
    String tailShape;

    Dog(String type, String earShape, String tailShape) {
        super(type);
        this.earShape = earShape;
        this.tailShape = tailShape;
    }

    @Override
    void makeNoise() {
        System.out.println(type + " barks loudly!");
    }

    void bark() {
        System.out.println(type + " barks.");
    }

    void wagTail() {
        System.out.println(type + " wags its " + tailShape + " tail.");
    }

    @Override
    public String toString() {
        return "Type: " + type + ", Ear Shape: " + earShape + ", Tail Shape: " + tailShape;
    }
}

// Hàm main để chạy chương trình
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog("Dog", "Perky", "Curled");
        System.out.println(dog.toString()); // In ra: Type: Dog, Ear Shape: Perky, Tail Shape: Curled
        dog.makeNoise(); // In ra: Dog barks loudly!
        dog.bark(); // In ra: Dog barks.
        dog.wagTail(); // In ra: Dog wags its Curled tail.
    }
}
```

**Kết quả:**

```
Type: Dog, Ear Shape: Perky, Tail Shape: Curled
Dog barks loudly!
Dog barks.
Dog wags its Curled tail.
```

---

Hy vọng rằng phiên bản này giúp bạn dễ hiểu hơn về khái niệm kế thừa và cách thực hiện nó trong Java!
